<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hacker Base — Secure Node</title>
<style>
  /* ====== Basic / Reset ====== */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    background:#000;
    color:#bfffb3;
    font-family: "Courier New", monospace;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }

  /* ====== matrix canvas ====== */
  #matrix {
    position:fixed;
    inset:0;
    z-index:0;
    background:radial-gradient(ellipse at center, rgba(0,0,0,0.15), rgba(0,0,0,0.6));
  }

  /* ====== Container ====== */
  .overlay {
    position:relative;
    z-index:2;
    display:flex;
    align-items:center;
    justify-content:center;
    height:100vh;
    padding:20px;
  }

  .panel {
    width:980px;
    max-width:96%;
    background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.45));
    border:1px solid rgba(142,242,122,0.08);
    padding:28px;
    border-radius:10px;
    box-shadow:0 8px 40px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.02);
    backdrop-filter: blur(4px);
    color:#c8ffbe;
    position:relative;
    overflow:visible;
  }

  .panel::after{
    content:"";
    pointer-events:none;
    position:absolute;
    inset:0;
    background-image:linear-gradient(rgba(255,255,255,0.01) 1px, transparent 1px);
    background-size:100% 4px;
    mix-blend-mode:overlay;
    border-radius:10px;
    z-index:1;
    opacity:0.12;
  }

  /* ====== Header ====== */
  .logo {
    font-size:20px;
    letter-spacing:2px;
    color:#9aff8b;
    display:flex;
    gap:12px;
    align-items:center;
    margin-bottom:14px;
  }
  .logo .dot{width:10px;height:10px;border-radius:50%;background:#7bff74;box-shadow:0 0 8px #7bff74}

  /* ====== Lock screen ====== */
  .lock { display:flex; gap:18px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
  .lock-left{ min-width:240px; max-width:620px; }
  .big-title{ font-size:34px; color:#baff9a; margin-bottom:8px; text-shadow:0 2px 8px rgba(0,0,0,0.8) }
  .subtitle{ color:#9dcf98; font-size:13px; margin-bottom:18px; }
  .lock-controls{ display:flex; gap:8px; align-items:center; }
  input[type="password"]{
    background:rgba(0,0,0,0.6);
    border:1px solid rgba(142,242,122,0.12);
    color:#bfffb3;
    padding:12px 14px;
    border-radius:8px;
    font-size:15px;
    outline:none;
    min-width:260px;
  }
  button{
    background:#0f0f0f;
    border:1px solid rgba(142,242,122,0.2);
    color:#d7ffcf;
    padding:12px 16px;
    border-radius:8px;
    cursor:pointer;
    font-weight:700;
    letter-spacing:1px;
    transition: transform .08s ease, box-shadow .12s ease, background .12s ease, color .12s ease;
  }
  button:hover{ transform: translateY(-2px); box-shadow:0 6px 18px rgba(0,255,120,0.06) }

  .hint{ font-size:12px; color:#7da77b; margin-top:10px; }

  /* ====== Dashboard ====== */
  .dashboard{ display:none; margin-top:18px; }
  .dash-top{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px; }
  .access-badge{
    background:linear-gradient(90deg,#052 #0b4);
    padding:8px 12px;border-radius:8px;color:#002a00;font-weight:800;letter-spacing:1px;
    box-shadow:0 6px 22px rgba(0,200,90,0.07), inset 0 -6px 18px rgba(0,0,0,0.35);
  }
  .devices{ display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:12px; margin-top:12px; }
  .device{ background:rgba(0,0,0,0.45); border:1px solid rgba(142,242,122,0.06); padding:12px; border-radius:8px; min-height:52px; display:flex; flex-direction:column; justify-content:center; gap:6px; }
  .device .name{ font-weight:700; color:#cfffbd }
  .device .meta{ font-size:12px; color:#88b889 }

  /* ====== Upload gallery ====== */
  .upload-row{ display:flex; gap:8px; align-items:center; margin-top:10px; flex-wrap:wrap; }
  #photoGallery, #videoGallery{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
  .media-card{
    width:140px; border-radius:8px; overflow:hidden; background:rgba(0,0,0,0.45); border:1px solid rgba(142,242,122,0.06);
    display:flex; flex-direction:column; gap:6px; padding:8px;
  }
  .media-card img, .media-card video{ width:100%; height:90px; object-fit:cover; border-radius:6px; background:#000; }
  .media-actions{ display:flex; gap:6px; justify-content:space-between; }

  .small{ font-size:12px; color:#7da77b; padding-top:8px; }

  /* ====== Hacker unlock animation ====== */
  .glow {
    position:absolute; inset:0; z-index:0; pointer-events:none; mix-blend-mode:screen; opacity:0;
    background: radial-gradient(ellipse at center, rgba(80,255,120,0.06), transparent 30%);
    transition: opacity .45s ease;
  }
  .glow.active{ opacity:1; }

  .banner {
    margin-top:10px; font-size:20px; font-weight:900; letter-spacing:2px; color:#bfffb3;
    text-shadow: 0 6px 40px rgba(0,255,120,0.06);
    overflow:hidden;
    display:inline-block;
  }

  /* tiny scanline flicker after unlock */
  .scanline{
    position: absolute; inset:0; z-index:3; pointer-events:none; mix-blend-mode:overlay;
    background-image: linear-gradient(rgba(255,255,255,0.01) 1px, transparent 1px);
    background-size:100% 4px; opacity:0.08;
  }

  /* small animation: glitch text */
  @keyframes glitch {
    0% { transform: translateX(0); opacity:1; }
    20% { transform: translateX(-2px); opacity:0.9; }
    40% { transform: translateX(2px); opacity:0.95; }
    60% { transform: translateX(-1px); opacity:0.92; }
    100% { transform: translateX(0); opacity:1; }
  }
  .glitch { animation: glitch 800ms infinite linear; }

  /* responsive */
  @media (max-width:640px){
    .big-title{ font-size:26px }
    input[type="password"]{ min-width:160px }
    .panel{ padding:16px }
  }
</style>
</head>
<body>
  <canvas id="matrix"></canvas>

  <div class="overlay" role="main">
    <div class="panel" id="panelRoot" aria-live="polite">
      <div class="logo"><span class="dot" aria-hidden="true"></span><div>HACKER BASE • SECURE NODE</div></div>

      <div class="lock" id="lockArea">
        <div class="lock-left">
          <div class="big-title">Access Node — Locked</div>
          <div class="subtitle" id="subtitleText">Enter credentials to reveal the secure base. Unauthorized access is not permitted.</div>

          <div class="lock-controls">
            <label for="pwd" class="sr-only">Password</label>
            <input id="pwd" type="password" placeholder="Enter access pass..." aria-label="Password input" />
            <button id="unlockBtn" aria-label="Unlock">UNLOCK</button>
          </div>
          <div class="hint" id="hintLine">Tip: Press Enter after typing the password.</div>
        </div>

        <div style="min-width:220px; text-align:right;">
          <div style="font-size:13px;color:#7db68a;font-weight:700">NODE STATUS</div>
          <div style="font-size:30px;margin-top:8px;color:#8ff58f" id="statusBig">● LOCKED</div>
          <div style="font-size:12px;color:#7aa573;margin-top:8px">Secure Layer • Client-only demo</div>
        </div>
      </div>

      <!-- DASHBOARD -->
      <div class="dashboard" id="dashboard" aria-hidden="true">
        <div class="dash-top">
          <div style="display:flex;gap:12px;align-items:center">
            <div class="banner" id="accessBanner">ACCESS GRANTED</div>
            <div class="access-badge">NODE: VX-42</div>
          </div>
          <div style="font-size:13px;color:#89b985" id="timeLabel"></div>
        </div>

        <div style="font-size:13px;color:#9ccf98">Active Connections</div>
        <div class="devices" id="devices"></div>

        <!-- upload controls -->
        <div style="margin-top:14px; display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap">
          <div style="font-size:13px;color:#9ccf98">Media Uploads</div>
          <div style="font-size:12px;color:#7da77b">Files are saved locally in your browser (client-only). To share across users, use server storage.</div>
        </div>

        <div class="upload-row">
          <input id="mediaInput" type="file" accept="image/*,video/*" multiple />
          <button id="uploadBtn">UPLOAD</button>
          <button id="clearBtn">CLEAR ALL</button>
          <button id="exportBtn">EXPORT JSON</button>
        </div>

        <div class="small">Tip: You can copy a file's data URL with the copy button on each card. Large videos may exceed browser storage limits.</div>

        <div style="margin-top:14px;">
          <div style="font-size:13px;color:#9ccf98">Photo Gallery</div>
          <div id="photoGallery"></div>
        </div>

        <div style="margin-top:14px;">
          <div style="font-size:13px;color:#9ccf98">Video Gallery</div>
          <div id="videoGallery"></div>
        </div>

        <div class="small" style="margin-top:12px">Client-only simulation. To securely share uploads between users, implement a server endpoint (I can provide Node/Express code if you want).</div>
      </div>

      <div class="glow" id="glow"></div>
      <div class="scanline"></div>
    </div>
  </div>

<script>
/* =========================
   CONFIG
   ========================= */
const CONFIG = {
  password: 'smdk@2025',   // <-- CHANGE THIS to set your password
  simulateDevices: [
    'device-therm-03','xphone-pro-7','workstation-ny-12','sensor-hub-A1',
    'raspi-gateway','telemetry-5G-9','unknown-0x9f','terminal-alpha'
  ],
  deviceIntervalMs: 900,
  storageKey: 'hb_media_v1', // localStorage key
};

/* =========================
   MATRIX BACKGROUND
   ========================= */
const canvas = document.getElementById('matrix');
const ctx = canvas.getContext('2d');
let W = innerWidth, H = innerHeight, cols, yPos;
function resize() {
  canvas.width = W = innerWidth;
  canvas.height = H = innerHeight;
  cols = Math.floor(W / 14) + 1;
  yPos = Array(cols).fill(0).map(()=>Math.floor(Math.random()*H));
}
addEventListener('resize', resize);
resize();

const letters = "アァカサタナハマヤャラワィイキシチニヒミリヰウヴ".split('').concat("01".split(''));
function drawMatrix(){
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fillRect(0,0,W,H);
  ctx.font = '14px monospace';
  for(let i=0;i<cols;i++){
    const text = letters[Math.floor(Math.random()*letters.length)];
    const x = i*14;
    ctx.fillStyle = 'rgba(30,255,120,0.9)';
    ctx.fillText(text,x,yPos[i]);
    yPos[i] += 14 + Math.random()*8;
    if (yPos[i] > H + Math.random()*1000) yPos[i] = 0;
  }
}
let matrixAnim = setInterval(drawMatrix, 55);

/* =========================
   UI ELEMENTS
   ========================= */
const pwd = document.getElementById('pwd');
const unlockBtn = document.getElementById('unlockBtn');
const dashboard = document.getElementById('dashboard');
const devicesEl = document.getElementById('devices');
const timeLabel = document.getElementById('timeLabel');
const statusBig = document.getElementById('statusBig');
const subtitleText = document.getElementById('subtitleText');
const glide = document.getElementById('glow');
const banner = document.getElementById('accessBanner');

let deviceTimer = null;

/* time update */
function updateTime(){
  timeLabel.textContent = new Date().toLocaleString();
}
setInterval(updateTime,1000);
updateTime();

/* device simulation */
function simulateDeviceJoin(){
  if (!dashboard.classList.contains('active')) return;
  const next = CONFIG.simulateDevices[Math.floor(Math.random()*CONFIG.simulateDevices.length)];
  const node = document.createElement('div');
  node.className = 'device';
  const name = document.createElement('div'); name.className = 'name'; name.textContent = next;
  const meta = document.createElement('div'); meta.className='meta';
  meta.textContent = 'peer @ ' + new Date().toLocaleTimeString();
  node.appendChild(name); node.appendChild(meta);
  devicesEl.prepend(node);
  while (devicesEl.children.length > 12) devicesEl.removeChild(devicesEl.lastChild);
}

/* =========================
   UNLOCK LOGIC + ANIMATION
   ========================= */
function setLocked(isLocked){
  statusBig.textContent = isLocked ? '● LOCKED' : '● ONLINE';
}
function smallAnnounce(text){
  const el = document.createElement('div');
  el.style.position='fixed'; el.style.left='18px'; el.style.bottom='18px';
  el.style.padding='8px 12px'; el.style.borderRadius='8px'; el.style.background='rgba(0,0,0,0.5)';
  el.style.border='1px solid rgba(142,242,122,0.08)'; el.style.color='#cfffbd';
  document.body.appendChild(el);
  let i=0;
  const t = setInterval(()=>{ el.textContent = text.slice(0, ++i); if (i>=text.length) clearInterval(t); }, 28);
  setTimeout(()=>el.remove(), 4200);
}

function doUnlockAnimation(){
  // banner glitch, glow, speed up matrix
  banner.classList.add('glitch');
  glide.classList.add('active');
  clearInterval(matrixAnim);
  matrixAnim = setInterval(drawMatrix, 30);

  // animate banner typing
  const text = 'ACCESS GRANTED — NODE VX-42';
  banner.textContent = '';
  let i = 0;
  const t = setInterval(()=> {
    banner.textContent = text.slice(0, ++i);
    if (i >= text.length) {
      clearInterval(t);
      banner.classList.remove('glitch');
    }
  }, 28);

  // little particle burst (canvas overlay)
  burstParticles();
}

/* small particle burst overlay */
function burstParticles(){
  const pCanvas = document.createElement('canvas');
  pCanvas.style.position='fixed'; pCanvas.style.left=0; pCanvas.style.top=0; pCanvas.style.zIndex=4;
  pCanvas.width = innerWidth; pCanvas.height = innerHeight;
  document.body.appendChild(pCanvas);
  const pCtx = pCanvas.getContext('2d');
  const particles = [];
  for(let i=0;i<60;i++){
    particles.push({
      x: innerWidth/2 + (Math.random()-0.5)*200,
      y: innerHeight/2 + (Math.random()-0.5)*100,
      vx: (Math.random()-0.5)*8,
      vy: (Math.random()-0.8)*6,
      life: 40 + Math.random()*40,
      size: 1 + Math.random()*3,
      col: `rgba(80,255,140,${0.6+Math.random()*0.4})`
    });
  }
  let frame = 0;
  const anim = setInterval(()=>{
    pCtx.clearRect(0,0,pCanvas.width,pCanvas.height);
    for(const pr of particles){
      pCtx.fillStyle = pr.col;
      pCtx.beginPath();
      pCtx.arc(pr.x, pr.y, pr.size, 0, Math.PI*2);
      pCtx.fill();
      pr.x += pr.vx; pr.y += pr.vy; pr.life--;
      pr.size *= 0.98;
    }
    frame++;
    if (frame > 80) { clearInterval(anim); pCanvas.remove(); }
  }, 30);
}

/* unlock handler */
async function unlock(){
  const val = pwd.value || '';
  if (val === CONFIG.password){
    // success
    subtitleText.textContent = 'Welcome back operator — session active.';
    setLocked(false);
    dashboard.style.display = 'block';
    dashboard.classList.add('active');
    dashboard.setAttribute('aria-hidden','false');
    // stop intense matrix? speed up
    doUnlockAnimation();
    simulateDeviceJoin();
    deviceTimer = setInterval(simulateDeviceJoin, CONFIG.deviceIntervalMs);
    smallAnnounce('SESSION STARTED — NODE VX-42');
    // show upload controls (no-op — always present)
    loadSavedMedia(); // restore media
  } else {
    // fail: shake + hint
    const el = document.querySelector('.panel');
    el.animate([{ transform: 'translateX(0)' }, { transform: 'translateX(-6px)' }, { transform: 'translateX(6px)' }, { transform: 'translateX(0)' }], { duration: 320 });
    const hintEl = document.getElementById('hintLine'); const old = hintEl.textContent;
    hintEl.textContent = 'Access Denied — wrong pass.';
    setTimeout(()=> hintEl.textContent = old, 1200);
  }
}
unlockBtn.addEventListener('click', unlock);
pwd.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') unlock(); });
window.addEventListener('load', ()=> pwd.focus());

/* expose small debug functions */
window.__HB = {
  unlockNow: function(){ pwd.value = CONFIG.password; unlock(); },
  clearDevices: function(){ devicesEl.innerHTML = ''; },
  stop: function(){ if (deviceTimer) clearInterval(deviceTimer); }
};

/* =========================
   MEDIA UPLOAD / PERSISTENCE
   ========================= */
const mediaInput = document.getElementById('mediaInput');
const uploadBtn = document.getElementById('uploadBtn');
const clearBtn = document.getElementById('clearBtn');
const exportBtn = document.getElementById('exportBtn');
const photoGallery = document.getElementById('photoGallery');
const videoGallery = document.getElementById('videoGallery');

uploadBtn.addEventListener('click', handleUpload);
clearBtn.addEventListener('click', clearAll);
exportBtn.addEventListener('click', exportJSON);

/* read saved media list from localStorage */
function loadSavedMedia(){
  photoGallery.innerHTML = ''; videoGallery.innerHTML = '';
  try {
    const raw = localStorage.getItem(CONFIG.storageKey);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (data.photos && Array.isArray(data.photos)) data.photos.forEach((d,i)=> createMediaCard('image', d, i));
    if (data.videos && Array.isArray(data.videos)) data.videos.forEach((d,i)=> createMediaCard('video', d, i));
  } catch(e){ console.warn('Failed to load media', e); }
}

/* persist current arrays */
function persistMedia(photos, videos){
  try {
    const payload = { photos, videos };
    localStorage.setItem(CONFIG.storageKey, JSON.stringify(payload));
    return true;
  } catch(e){
    console.warn('Persistence failed', e);
    alert('Saving failed — likely localStorage quota exceeded. Try smaller files or clear some media.');
    return false;
  }
}

/* get arrays from DOM (or localStorage) */
function currentMediaArrays(){
  const raw = localStorage.getItem(CONFIG.storageKey);
  if (!raw) return { photos: [], videos: [] };
  try { return JSON.parse(raw); } catch { return { photos: [], videos: [] }; }
}

/* handle user upload */
function handleUpload(){
  const files = mediaInput.files;
  if (!files || files.length === 0) return alert('Select files first!');
  // load existing
  const cur = currentMediaArrays();
  const photos = cur.photos || [];
  const videos = cur.videos || [];
  let pending = files.length;
  const failMsg = [];
  for (const file of files){
    const reader = new FileReader();
    reader.onerror = ()=> { failMsg.push(file.name + ' read error'); pending--; if (pending===0) finalize(); };
    reader.onload = (e) => {
      const dataUrl = e.target.result;
      try {
        if (file.type.startsWith('image')){
          photos.unshift(dataUrl);
        } else if (file.type.startsWith('video')){
          videos.unshift(dataUrl);
        } else {
          failMsg.push(file.name + ' unsupported type');
        }
      } catch(err){
        failMsg.push(file.name + ' processing error');
      }
      pending--; if (pending===0) finalize();
    };
    reader.readAsDataURL(file);
  }

  function finalize(){
    // try save
    const ok = persistMedia(photos, videos);
    if (ok){
      loadSavedMedia();
      mediaInput.value = '';
      smallAnnounce('UPLOAD COMPLETE');
      if (failMsg.length) alert('Some files failed:\n' + failMsg.join('\n'));
    }
  }
}

/* create UI card for a media item */
function createMediaCard(type, dataUrl, index){
  // create container
  const card = document.createElement('div'); card.className = 'media-card';
  // media
  if (type === 'image'){
    const img = document.createElement('img'); img.src = dataUrl; img.alt = 'Uploaded image';
    card.appendChild(img);
  } else if (type === 'video'){
    const vid = document.createElement('video'); vid.src = dataUrl; vid.controls = true; vid.preload='metadata';
    card.appendChild(vid);
  }

  // actions row
  const actions = document.createElement('div'); actions.className = 'media-actions';
  const copyBtn = document.createElement('button'); copyBtn.textContent = 'COPY URL'; copyBtn.style.fontSize='12px';
  copyBtn.addEventListener('click', async ()=>{
    try { await navigator.clipboard.writeText(dataUrl); copyBtn.textContent = 'COPIED'; setTimeout(()=>copyBtn.textContent='COPY URL',900); }
    catch(e){ alert('Copy failed — open in new tab to save.'); }
  });

  const downloadBtn = document.createElement('button'); downloadBtn.textContent = 'DL'; downloadBtn.style.fontSize='12px';
  downloadBtn.addEventListener('click', ()=> {
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = type === 'image' ? `image_${Date.now()}.png` : `video_${Date.now()}.mp4`;
    document.body.appendChild(a); a.click(); a.remove();
  });

  const delBtn = document.createElement('button'); delBtn.textContent = 'DEL'; delBtn.style.fontSize='12px';
  delBtn.addEventListener('click', () => {
    const cur = currentMediaArrays();
    if (type === 'image'){ cur.photos.splice(index, 1); }
    else { cur.videos.splice(index, 1); }
    persistMedia(cur.photos, cur.videos);
    loadSavedMedia();
  });

  actions.appendChild(copyBtn); actions.appendChild(downloadBtn); actions.appendChild(delBtn);
  card.appendChild(actions);

  if (type === 'image') photoGallery.appendChild(card); else videoGallery.appendChild(card);
}

/* we need to re-create cards from arrays in order with accurate indices.
   loadSavedMedia does this by iterating photos/videos and calling createMediaCard
   but createMediaCard currently uses the index passed; when items are deleted,
   we reload from scratch so indices align. */
function refreshGalleries(){
  photoGallery.innerHTML = ''; videoGallery.innerHTML = '';
  const cur = currentMediaArrays();
  (cur.photos || []).forEach((d,i)=> createMediaCard('image', d, i));
  (cur.videos || []).forEach((d,i)=> createMediaCard('video', d, i));
}

/* wrapper used by loadSavedMedia */
function loadSavedMedia(){
  photoGallery.innerHTML = ''; videoGallery.innerHTML = '';
  try {
    const raw = localStorage.getItem(CONFIG.storageKey);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (data.photos && data.photos.length){
      data.photos.forEach((d,i)=> createMediaCard('image', d, i));
    }
    if (data.videos && data.videos.length){
      data.videos.forEach((d,i)=> createMediaCard('video', d, i));
    }
  } catch(e){ console.warn('Failed to load media', e); }
}

/* clear all */
function clearAll(){
  if (!confirm('Delete all uploaded media from this browser?')) return;
  localStorage.removeItem(CONFIG.storageKey);
  photoGallery.innerHTML = ''; videoGallery.innerHTML = '';
  smallAnnounce('MEDIA CLEARED');
}

/* export current media as JSON (useful to save or share) */
function exportJSON(){
  const cur = currentMediaArrays();
  const blob = new Blob([JSON.stringify(cur)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'hackerbase_media.json';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* initial load from storage */
loadSavedMedia();

/* =========================
   Small polishing: prevent accidental navigation away
   ========================= */
window.addEventListener('beforeunload', (e)=>{
  // only prompt if there is media (to prevent accidental loss)
  const cur = currentMediaArrays();
  if ((cur.photos && cur.photos.length) || (cur.videos && cur.videos.length)){
    e.preventDefault();
    e.returnValue = '';
    return '';
  }
});

/* =========================
   End of script
   ========================= */
</script>
</body>
</html>
